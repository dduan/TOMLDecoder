# How to Decode TOML

Learn how to convert TOML into your Codable types.

## Overview

Swift's standard library defines the `Encodable`,
and `Decodable` protocols.
Combined, they form the superset, `Codable` protocol.
If your types conform to `Decodable`, or `Codable`,
`TOMLDecoder` can create instances of your types from TOML data.

The API for doing so is very similar to the `JSONDecoder` API from `Foundation`.

```swift
struct Config: Codable {
    let title: String
    ...
}
let toml: String = """
title = "TOML Example"
...
"""

var decoder = TOMLDecoder()
decoder.strategy = ... // optionally customize decoder behavior
try TOMLDecoder().decode(Config.self, from: toml)

print(config.title) // "TOML Example"
```

In order to decode TOML into instances of your type,
TOMLDecoder first parses the data into a strict set of
structural, or leaf types (<doc:DeserializingTOML>).

But unlike the parsing phase,
the decoding phase tries to accommodate different types in your `Decodable`.
For example,
an integer is parsed as an `Int64`,
but if you need a `UInt` in your `Decodable` type,
TOMLDecoder will attempt the conversion
instead of rejecting the request with an error.

Like other options,
this lenient, automatic conversion can be turned off
by setting the ``/TOMLDecoder/TOMLDecoder/isLenient`` property.


## Decoding strategies

Similar to Foundation's `JSONDecoder`,
you can change ``/TOMLDecoder/TOMLDecoder``'s behavior by specifying
different decoding strategies.

### Table key strategies

To change how table keys map into your property names,
set ``/TOMLDecoder/TOMLDecoder/Strategy/key``.
For example,
``/TOMLDecoder/TOMLDecoder/KeyStrategy/convertFromSnakeCase``
causes a key `ice_cream` in TOML
to map to the property `iceCream` on your `Decodable` type.

### Time interval strategies

You may choose to represent a TOML offset date-time as a time interval since a reference date.

You may also choose to interpret a TOML float as a time interval from a reference date.

Both are allowed as long as ``/TOMLDecoder/TOMLDecoder/isLenient`` is `true`.

You can control the reference date by setting ``/TOMLDecoder/TOMLDecoder/Strategy/timeInterval``.

This option has no effect if the decoded property is a ``/TOMLDecoder/OffsetDateTime``.

### Date strategies

In TOML, an offset date-time represents a point in time.
It's supposed to be interpreted as a date on the *proleptic Gregorian calendar*.
That's a fancy way of saying a date in the current Gregorian calendar system,
applied backwards as if it has always been in use.

A point in time is conventionally represented as a `Foundation.Date` in Swift.
However, Foundation's Gregorian calendar is *not* proleptic.
It uses the *Julian calendar* for dates before October 15, 1582.
If one constructs a `DateComponents` with an old date prior to that cutoff date,
and creates a `Date` from it using Foundation's Gregorian calendar,
the `.timeIntervalSince1970` property of the resulting `Date` will disagree
with the intended point in time in TOML.
But this isn't a problem for modern dates.

For this reason,
``/TOMLDecoder/TOMLDecoder/DateStrategy`` provides options for dealing with this
discrepancy for `Foundation` dates.
A TOML offset date-time provides the components of a date.
This strategy lets you decide how the components are converted into a `Foundation.Date`.

By default, the date conversion is done by Foundation's Gregorian calendar.
You may also choose an arbitrary calendar by specifying a calendar identifier.
Or, you can choose the proleptic Gregorian calendar,
which means the number of seconds is calculated by TOMLDecoder using the
proleptic Gregorian rules, and then used to create the `Date`.

If you only need to deal with modern dates, the default option should be sufficient.

## Supported type conversions

When ``/TOMLDecoder/TOMLDecoder/isLenient`` is `true` (the default),
TOMLDecoder will attempt to convert the value from the type
generated by the parser
to a related type from Swift's standard library,
or Foundation.
You may use the original type generated by the parser,
or one of the other related types in your `Decodable` to
represent the TOML value.
The rest of this section is a list of all the supported types.

### TOML Integer

TOML integers are parsed as `Int64`.

TOMLDecoder will attempt to convert it to the following types,
if the original number can be represented by the type.

* `Int`
* `Int32`
* `Int16`
* `Int8`
* `UInt`
* `UInt64`
* `UInt32`
* `UInt16`
* `UInt8`

### TOML Float

TOML floating numbers are parsed as `Double`.
TOMLDecoder will attempt to convert them to a `Float`.

You may also interpret a float as a time interval,
and represent it as a `Foundation.Date`.
See ``/TOMLDecoder/TOMLDecoder/TimeIntervalStrategy``.

### TOML String

A TOML string can only be represented by `String`.

### TOML Offset Date-Time

TOML offset date-times are parsed as ``/TOMLDecoder/OffsetDateTime``s.

TOMLDecoder will attempt to convert it to

* `Foundation.Date`
* `Double` / `TimeInterval`
* ``/TOMLDecoder/LocalDateTime``
* ``/TOMLDecoder/LocalDate``
* ``/TOMLDecoder/LocalTime``

When converting to local date/time types,
the timezone offset is discarded.

See ``/TOMLDecoder/TOMLDecoder/TimeIntervalStrategy``
to learn about conversion to `Double`.

See ``/TOMLDecoder/TOMLDecoder/DateStrategy`` about conversion to `Date`.

### TOML Local Date-Time

Parsed as ``/TOMLDecoder/LocalDateTime``.

TOMLDecoder will attempt to convert it to

* `Foundation.DateComponents`
* ``/TOMLDecoder/LocalDate``
* ``/TOMLDecoder/LocalTime``

### TOML Local Date

Parsed as ``/TOMLDecoder/LocalDate``.

TOMLDecoder will attempt to convert it to

* `Foundation.DateComponents`

### TOML Local Time

Parsed as ``/TOMLDecoder/LocalTime``.

TOMLDecoder will attempt to convert it to

* `Foundation.DateComponents`

### TOML Table

Parsed as ``/TOMLDecoder/TOMLTable``.

TOMLDecoder will attempt to convert it to a `Dictionary<String, Any>`.


### TOML Array

Parsed as ``/TOMLDecoder/TOMLArray``.

TOMLDecoder will attempt to convert it to an `Array<Any>`.
