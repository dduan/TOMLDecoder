# Developing TOMLDecoder

Notes for TOMLDecoder maintainers.

## Writing Code

Use [swiftformat](https://github.com/nicklockwood/SwiftFormat/tree/main),
ideally, the version specified in `Scripts/format.sh` to format all code.
Patches containing unformatted code should not be accepted.
We recommend adding `swiftformat --lint .` in git pre-commit hooks.


## Writing documentation

All APIs should be documented.
Documentation should use Semantic Line Breaks.
This applies to docstrings, code comments, and articles.
In short, at most one sentence per line.
Read https://sembr.org/ for more info.


## Deploying documentation

Documentation is hosted as a website hosted on GitHub pages.
It's generated by  [swift-docc](https://github.com/swiftlang/swift-docc).
Each release, as well as the `main` branch, has its own site.

Generate the site with `Scripts/generate-docs.sh /TOMLDecoder/VERSION`.

Deploy the site with `Scripts/deploy-docs.sh VERSION`.

## Testing

Write tests with Swift's Testing framework.

Our unit tests include the [official suite](https://github.com/toml-lang/toml-test)
from the TOML GitHub organization,
systematically translated into Swift tests.

Run tests with `swift test`, as well as `bazel test //...`.

Tests must pass on macOS, Ubuntu, and Windows for any changes to land.


## Generating Code, and Tests

* Parts of the code are written using `gyb`.
  Use the script `Scripts/generate-code.sh` to generate the code.
  The generated code is checked into the repo.
  Look for header comments indicating generated code,
  and only make changes in the corresponding `.gyb` files during development.
* A subset of tests are generated
  by directly copying fixtures for the official test suite.
  This is done by a script `Scripts/generate-tests.py`.
  The generated tests and fixtures are checked into the repo.
  The script contains a SHA of the test suite repo
  from which the tests are copied.
  Update the SHA to get potential newer tests.
* The script `Scripts/test-generate.sh` should be run
  to verify that the generated code and tests are up to date.
  It exits with a non-zero exit code if new code is generated.
* Generated source files should have `.Generated.swift` suffix in the filename.


## Benchmarking

Use `Scripts/benchmark.sh baseline-SHA new-SHA`
to compare performance between two commits.

## Releasing

* Pick a new version number according to [Semantic Versioning](https://semver.org/).
* Places referencing the latest version need to be updated:
    - Instructions for adding TOMLDecoder as a SwiftPM dependency
      in Getting Started.
    - Link in README.md to the latest versioned docs.
    - MODULE.bazel
    - Potentially other places.
      Search for the old version number in the repo.
* In CHANGELOG.md, create section for the new release.
  Move any content under `Development` to the new section.
  Note any changes that aren't in the existing notes.
* Add a link to the would-be link versioned doc site in
  `TOMLDecoder.docc/VersionedDocs.md`.
* Check in the above changes and land the commit to the `main` branch.
* Tag the commit on `main` created from the previous step.
  The tag should be the literal version number (No `v` prefix).
  Push the tag to GitHub.
* Create a draft release referencing the tag on GitHub.
* Download all source archives included in the release in an empty directory.
  Run `shasum -a 256 *`.
  Include the output as a code block in the release notes.
* Publish the release on GitHub.
* Generate and deploy the documentation site for the new release.

## Architecture Overview

TOMLDecoder is a parser with a `Swift.Decoder` implementation sitting on top.

TOML has a spec,
and a large number of parser implementations in many languages.
Among them,
TOMLDecoder's parser is of the garden variety.
The parsing occurs in 2 stages,
each triggered by different API calls.
<doc:DeserializingTOML#The-Deserialization-Process> describes this at a high level.

When we make a ``TOMLTable`` out of the TOML document,
we analyze the structure of the document,
find out where the key-value pairs are,
the tables, and the arrays.
Crucially,
we don't attempt to validate the leaf values in
tables or arrays.
This validation is deferred as these leaf values are needed
by the decoder,
or requested by the user via,
for example,
``/TOMLDecoder/TOMLTable/string(forKey:)``.
