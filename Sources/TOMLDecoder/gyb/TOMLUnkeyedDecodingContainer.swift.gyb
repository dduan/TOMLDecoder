%{
# gyb variables available: `__file__` gives the templateâ€™s path.
from pathlib import Path
template_name = Path(__file__).name
generated_file = template_name[:-4] if template_name.endswith('.gyb') else template_name
}%
//  WARNING: This file is generated from ${template_name}
//  Do not edit ${generated_file} directly.
import Foundation

struct TOMLUnkeyedDecodingContainer: UnkeyedDecodingContainer {
    private let decoder: _TOMLDecoder
    private let array: TOMLArray

    /// The path of coding keys taken to get to this point in decoding.
    var codingPath: [CodingKey] {
        self.decoder.codingPath
    }

    /// The index of the element we're about to decode.
    private(set) var currentIndex: Int

    // MARK: - UnkeyedDecodingContainer Methods

    var count: Int? {
        return self.array.count
    }

    var isAtEnd: Bool {
        return self.currentIndex >= self.count!
    }

    init(referencing decoder: _TOMLDecoder, wrapping array: TOMLArray) {
        self.decoder = decoder
        self.array = array
        self.currentIndex = 0
    }

    mutating func decodeNil() throws -> Bool {
        return false
    }

    mutating func decode(_ type: Double.Type) throws -> Double {
        guard !self.isAtEnd else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: self.codingPath + [TOMLKey(intValue: self.currentIndex)], debugDescription: "Unkeyed container is at end."))
        }

        do {
            let decoded = try self.array.float(atIndex: self.currentIndex)
            self.currentIndex += 1
            return decoded
        } catch {
            do {
                let offsetDateTime = try decode(OffsetDateTime.self)
                return try TimeInterval(from: offsetDateTime, strategy: self.decoder.strategy.offsetDateTime)
            } catch let error as DecodingError {
                throw error
            } catch {
                throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: self.codingPath + [TOMLKey(intValue: self.currentIndex)], debugDescription: "No float found at index \(self.currentIndex)."))
            }
        }
    }

   mutating func decode(_ type: Float.Type) throws -> Float {
       if !self.decoder.isLenient {
           throw DecodingError.typeMismatch(type, DecodingError.Context(
               codingPath: self.codingPath + [TOMLKey(intValue: self.currentIndex)],
               debugDescription: "Use Double or lenient number decoding strategy."
           ))
       }
       do {
            return Float(try decode(Double.self))
        } catch {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: self.codingPath + [TOMLKey(intValue: self.currentIndex)], debugDescription: "\(error)", underlyingError: error))
        }
   }

    %{
    int_types = ["Int", "Int8", "Int16", "Int32", "UInt", "UInt8", "UInt16", "UInt32", "UInt64"]
    }%
    % for int_type in int_types:
    mutating func decode(_ type: ${int_type}.Type) throws -> ${int_type} {
        let index = currentIndex - 1
        if !self.decoder.isLenient {
            throw DecodingError.typeMismatch(type, DecodingError.Context(
                codingPath: self.codingPath + [TOMLKey(intValue: index)],
                debugDescription: "Use Int64 or lenient number decoding strategy."
            ))
        }

        let integer = try decode(Int64.self)
        do {
            guard let result = ${int_type}(exactly: integer) else {
                throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: self.codingPath + [TOMLKey(intValue: index)], debugDescription: "Failed to convert integer \(integer) to ${int_type}."))
            }
            return result
        } catch {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: self.codingPath + [TOMLKey(intValue: index)], debugDescription: "Failed to convert integer \(integer) to \(type).", underlyingError: error))
        }
    }
    % end

    %{
    native_types = [("Int64", "integer"), ("OffsetDateTime", "offsetDateTime"), ("LocalDateTime", "localDateTime"), ("LocalDate", "localDate"), ("LocalTime", "localTime"), ("String", "string"), ("Bool", "bool")]
    }%
    % for type in native_types:
    mutating func decode(_ type: ${type[0]}.Type) throws -> ${type[0]} {
        guard !self.isAtEnd else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: self.codingPath + [TOMLKey(intValue: self.currentIndex)], debugDescription: "Unkeyed container is at end."))
        }
        do {
            let decoded = try self.array.${type[1]}(atIndex: self.currentIndex)
            self.currentIndex += 1
            return decoded
        } catch {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: self.codingPath + [TOMLKey(intValue: self.currentIndex)], debugDescription: "\(error)", underlyingError: error))
        }
    }
    % end

    mutating func decode<T>(_ type: T.Type) throws -> T where T: Decodable {
        guard !self.isAtEnd else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: self.codingPath + [TOMLKey(intValue: self.currentIndex)], debugDescription: "Unkeyed container is at end."))
        }

        var nestedCodingPath = self.codingPath
        nestedCodingPath.append(TOMLKey(intValue: self.currentIndex))

        %{
        # Combine all the types that have specific decode methods
        all_supported_types = (
            # Native types that are generated above
            [(t[0], t[0]) for t in native_types] +
            # Integer types that are generated above  
            [(t, t) for t in int_types] +
            # Special types with custom decode methods
            [("Date", "Date"), ("Float", "Float"), ("Double", "Double")]
        )
        }%
        % for i, (type_name, decode_type) in enumerate(all_supported_types):
        ${"if" if i == 0 else "} else if"} type == ${type_name}.self {
            return try decode(${decode_type}.self) as! T
        % end
        }

        // Try to get nested table or array
        if let nestedTable = try? self.array.table(atIndex: self.currentIndex) {
            let nestedDecoder = _TOMLDecoder(referencing: .keyed(nestedTable), at: nestedCodingPath, strategy: self.decoder.strategy, isLenient: self.decoder.isLenient)
            let decoded = try T(from: nestedDecoder)
            self.currentIndex += 1
            return decoded
        } else if let nestedArray = try? self.array.array(atIndex: self.currentIndex) {
            let nestedDecoder = _TOMLDecoder(referencing: .unkeyed(nestedArray), at: nestedCodingPath, strategy: self.decoder.strategy, isLenient: self.decoder.isLenient)
            let decoded = try T(from: nestedDecoder)
            self.currentIndex += 1
            return decoded
        } else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: self.codingPath + [TOMLKey(intValue: self.currentIndex)], debugDescription: "Expected \(type) but found unsupported type instead."))
        }
    }

    mutating func decode(_ type: Date.Type) throws -> Date {
        if !self.decoder.isLenient {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: self.codingPath + [TOMLKey(intValue: self.currentIndex)], debugDescription: "No date found at index \(self.currentIndex)."))
        }

        switch self.decoder.strategy.offsetDateTime {
        case .intervalSince1970:
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: self.codingPath + [TOMLKey(intValue: self.currentIndex)], debugDescription: "No date found at index \(self.currentIndex)."))
        case .intervalSince2001:
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: self.codingPath + [TOMLKey(intValue: self.currentIndex)], debugDescription: "No date found at index \(self.currentIndex)."))
        case .dateFromGregorianCalendar:
            do {
                let offsetDateTime = try decode(OffsetDateTime.self)
                return Date(offsetDateTime: offsetDateTime, calendar: Calendar(identifier: .gregorian))
            } catch {
                throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: self.codingPath + [TOMLKey(intValue: self.currentIndex)], debugDescription: "No date found at index \(self.currentIndex)."))
            }
        case .dateFromCalendar(let identifier):
            do {
                let offsetDateTime = try decode(OffsetDateTime.self)
                return Date(offsetDateTime: offsetDateTime, calendar: Calendar(identifier: identifier))
            } catch {
                throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: self.codingPath + [TOMLKey(intValue: self.currentIndex)], debugDescription: "No date found at index \(self.currentIndex)."))
            }
        case .dateFromProlepticGregorianCalendar:
            do {
                let offsetDateTime = try decode(OffsetDateTime.self)
                return Date(timeIntervalSinceReferenceDate: offsetDateTime.timeIntervalSince2001)
            } catch {
                throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: self.codingPath + [TOMLKey(intValue: self.currentIndex)], debugDescription: "No date found at index \(self.currentIndex)."))
            }
        }
    }

    mutating func nestedContainer<NestedKey>(keyedBy type: NestedKey.Type) throws -> KeyedDecodingContainer<NestedKey> where NestedKey : CodingKey {
        guard !self.isAtEnd else {
            throw DecodingError.valueNotFound(
                KeyedDecodingContainer<NestedKey>.self,
                DecodingError.Context(
                    codingPath: self.codingPath + [TOMLKey(intValue: self.currentIndex)],
                    debugDescription: "Unkeyed container is at end."
                )
            )
        }

        guard let nestedTable = try? self.array.table(atIndex: self.currentIndex) else {
            throw DecodingError.typeMismatch(
                KeyedDecodingContainer<NestedKey>.self,
                DecodingError.Context(
                    codingPath: self.codingPath + [TOMLKey(intValue: self.currentIndex)],
                    debugDescription: "Element is not a table."
                )
            )
        }

        var nestedCodingPath = self.codingPath
        nestedCodingPath.append(TOMLKey(intValue: self.currentIndex))
        let nestedDecoder = _TOMLDecoder(referencing: .keyed(nestedTable), at: nestedCodingPath, strategy: self.decoder.strategy, isLenient: self.decoder.isLenient)

        self.currentIndex += 1
        let container = TOMLKeyedDecodingContainer<NestedKey>(referencing: nestedDecoder, wrapping: nestedTable)
        return KeyedDecodingContainer(container)
    }

    mutating func nestedUnkeyedContainer() throws -> UnkeyedDecodingContainer {
        guard !self.isAtEnd else {
            throw DecodingError.valueNotFound(
                UnkeyedDecodingContainer.self,
                DecodingError.Context(codingPath: self.codingPath + [TOMLKey(intValue: self.currentIndex)],
                                      debugDescription: "Cannot get nested unkeyed container -- unkeyed container is at end."))
        }

        guard let nestedArray = try? self.array.array(atIndex: self.currentIndex) else {
            throw DecodingError.typeMismatch(UnkeyedDecodingContainer.self,
                                           DecodingError.Context(codingPath: self.codingPath + [TOMLKey(intValue: self.currentIndex)],
                                                               debugDescription: "Cannot get nested unkeyed container -- element is not an array."))
        }

        var nestedCodingPath = self.codingPath
        nestedCodingPath.append(TOMLKey(intValue: self.currentIndex))
        let nestedDecoder = _TOMLDecoder(referencing: .unkeyed(nestedArray), at: nestedCodingPath, strategy: self.decoder.strategy, isLenient: self.decoder.isLenient)

        self.currentIndex += 1
        return TOMLUnkeyedDecodingContainer(referencing: nestedDecoder, wrapping: nestedArray)
    }

    mutating func superDecoder() throws -> Decoder {
        guard !self.isAtEnd else {
            throw DecodingError.valueNotFound(
                Decoder.self,
                DecodingError.Context(codingPath: self.codingPath + [TOMLKey(intValue: self.currentIndex)],
                debugDescription: "Cannot get superDecoder() -- unkeyed container is at end."))
        }

        var nestedCodingPath = self.codingPath
        nestedCodingPath.append(TOMLKey(intValue: self.currentIndex))

        if let nestedTable = try? self.array.table(atIndex: self.currentIndex) {
            self.currentIndex += 1
            return _TOMLDecoder(referencing: .keyed(nestedTable), at: nestedCodingPath, strategy: self.decoder.strategy, isLenient: self.decoder.isLenient)
        } else if let nestedArray = try? self.array.array(atIndex: self.currentIndex) {
            self.currentIndex += 1
            return _TOMLDecoder(referencing: .unkeyed(nestedArray), at: nestedCodingPath, strategy: self.decoder.strategy, isLenient: self.decoder.isLenient)
        } else {
            throw DecodingError.valueNotFound(
                Decoder.self,
                DecodingError.Context(codingPath: self.codingPath + [TOMLKey(intValue: self.currentIndex)],
                debugDescription: "Cannot get superDecoder() -- element is not a table or array."
                )
            )
        }
    }
}
