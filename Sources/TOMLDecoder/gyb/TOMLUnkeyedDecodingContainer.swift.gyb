%{
# gyb variables available: `__file__` gives the templateâ€™s path.
from pathlib import Path
template_name = Path(__file__).name
generated_file = template_name[:-4] if template_name.endswith('.gyb') else template_name
}%
//  WARNING: This file is generated from ${template_name}
//  Do not edit ${generated_file} directly.
import Foundation

struct TOMLUnkeyedDecodingContainer: UnkeyedDecodingContainer {
    private let decoder: _TOMLDecoder
    private let array: TOMLArray

    /// The path of coding keys taken to get to this point in decoding.
    var codingPath: [CodingKey] {
        decoder.codingPath
    }

    /// The index of the element we're about to decode.
    private(set) var currentIndex: Int

    // MARK: - UnkeyedDecodingContainer Methods

    var count: Int? {
        array.count
    }

    var isAtEnd: Bool {
        currentIndex >= count!
    }

    init(referencing decoder: _TOMLDecoder, wrapping array: TOMLArray) {
        self.decoder = decoder
        self.array = array
        currentIndex = 0
    }

    mutating func decodeNil() throws -> Bool {
        false
    }

    mutating func decode(_ type: Double.Type) throws -> Double {
        guard !isAtEnd else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: codingPath + [TOMLKey(intValue: currentIndex)], debugDescription: "Unkeyed container is at end."))
        }

        do {
            let decoded = try array.float(atIndex: currentIndex)
            currentIndex += 1
            return decoded
        } catch {
            do {
                let offsetDateTime = try decode(OffsetDateTime.self)
                return try TimeInterval(from: offsetDateTime, strategy: decoder.strategy.offsetDateTime)
            } catch let error as DecodingError {
                throw error
            } catch {
                throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: codingPath + [TOMLKey(intValue: currentIndex)], debugDescription: "No float found at index \(currentIndex)."))
            }
        }
    }

    mutating func decode(_ type: Float.Type) throws -> Float {
        if !decoder.isLenient {
            throw DecodingError.typeMismatch(type, DecodingError.Context(
                codingPath: codingPath + [TOMLKey(intValue: currentIndex)],
                debugDescription: "Use Double or lenient number decoding strategy.",
            ))
        }
        do {
            return try Float(decode(Double.self))
        } catch {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: codingPath + [TOMLKey(intValue: currentIndex)], debugDescription: "\(error)", underlyingError: error))
        }
    }

    %{
    int_types = ["Int", "Int8", "Int16", "Int32", "UInt", "UInt8", "UInt16", "UInt32", "UInt64"]
    }%
    % for int_type in int_types:
    mutating func decode(_ type: ${int_type}.Type) throws -> ${int_type} {
        let index = currentIndex - 1
        if !decoder.isLenient {
            throw DecodingError.typeMismatch(type, DecodingError.Context(
                codingPath: codingPath + [TOMLKey(intValue: index)],
                debugDescription: "Use Int64 or lenient number decoding strategy.",
            ))
        }

        let integer = try decode(Int64.self)
        do {
            guard let result = ${int_type}(exactly: integer) else {
                throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: codingPath + [TOMLKey(intValue: index)], debugDescription: "Failed to convert integer \(integer) to ${int_type}."))
            }
            return result
        } catch {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: codingPath + [TOMLKey(intValue: index)], debugDescription: "Failed to convert integer \(integer) to \(type).", underlyingError: error))
        }
    }

    % end
    %{
    native_types = [("Int64", "integer"), ("OffsetDateTime", "offsetDateTime"), ("LocalDateTime", "localDateTime"), ("LocalDate", "localDate"), ("LocalTime", "localTime"), ("String", "string"), ("Bool", "bool"), ("TOMLArray", "array"), ("TOMLTable", "table")]
    }%
    % for type in native_types:
    mutating func decode(_ type: ${type[0]}.Type) throws -> ${type[0]} {
        guard !isAtEnd else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: codingPath + [TOMLKey(intValue: currentIndex)], debugDescription: "Unkeyed container is at end."))
        }
        do {
            let decoded = try array.${type[1]}(atIndex: currentIndex)
            currentIndex += 1
            return decoded
        } catch {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: codingPath + [TOMLKey(intValue: currentIndex)], debugDescription: "\(error)", underlyingError: error))
        }
    }

    % end
    mutating func decode<T>(_ type: T.Type) throws -> T where T: Decodable {
        guard !isAtEnd else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: codingPath + [TOMLKey(intValue: currentIndex)], debugDescription: "Unkeyed container is at end."))
        }

        var nestedCodingPath = codingPath
        nestedCodingPath.append(TOMLKey(intValue: currentIndex))

        %{
        # Combine all the types that have specific decode methods
        all_supported_types = (
            # Native types that are generated above
            [(t[0], t[0]) for t in native_types] +
            # Integer types that are generated above
            [(t, t) for t in int_types] +
            # Special types with custom decode methods
            [("Date", "Date"), ("Float", "Float"), ("Double", "Double")]
        )
        }%
        % for i, (type_name, decode_type) in enumerate(all_supported_types):
        ${"if" if i == 0 else "} else if"} type == ${type_name}.self {
            return try decode(${decode_type}.self) as! T
        % end
        }

        // Try to get nested table or array
        if let nestedTable = try? array.table(atIndex: currentIndex) {
            let nestedDecoder = _TOMLDecoder(referencing: .keyed(nestedTable), at: nestedCodingPath, strategy: decoder.strategy, isLenient: decoder.isLenient)
            let decoded = try T(from: nestedDecoder)
            currentIndex += 1
            return decoded
        } else if let nestedArray = try? array.array(atIndex: currentIndex) {
            let nestedDecoder = _TOMLDecoder(referencing: .unkeyed(nestedArray), at: nestedCodingPath, strategy: decoder.strategy, isLenient: decoder.isLenient)
            let decoded = try T(from: nestedDecoder)
            currentIndex += 1
            return decoded
        } else {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: codingPath + [TOMLKey(intValue: currentIndex)], debugDescription: "Expected \(type) but found unsupported type instead."))
        }
    }

    mutating func decode(_ type: Date.Type) throws -> Date {
        if !decoder.isLenient {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: codingPath + [TOMLKey(intValue: currentIndex)], debugDescription: "No date found at index \(currentIndex)."))
        }

        switch decoder.strategy.offsetDateTime {
        case .intervalSince1970:
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: codingPath + [TOMLKey(intValue: currentIndex)], debugDescription: "No date found at index \(currentIndex)."))
        case .intervalSince2001:
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: codingPath + [TOMLKey(intValue: currentIndex)], debugDescription: "No date found at index \(currentIndex)."))
        case .dateFromGregorianCalendar:
            do {
                let offsetDateTime = try decode(OffsetDateTime.self)
                return Date(offsetDateTime: offsetDateTime, calendar: Calendar(identifier: .gregorian))
            } catch {
                throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: codingPath + [TOMLKey(intValue: currentIndex)], debugDescription: "No date found at index \(currentIndex)."))
            }
        case let .dateFromCalendar(identifier):
            do {
                let offsetDateTime = try decode(OffsetDateTime.self)
                return Date(offsetDateTime: offsetDateTime, calendar: Calendar(identifier: identifier))
            } catch {
                throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: codingPath + [TOMLKey(intValue: currentIndex)], debugDescription: "No date found at index \(currentIndex)."))
            }
        case .dateFromProlepticGregorianCalendar:
            do {
                let offsetDateTime = try decode(OffsetDateTime.self)
                return Date(timeIntervalSinceReferenceDate: offsetDateTime.timeIntervalSince2001)
            } catch {
                throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: codingPath + [TOMLKey(intValue: currentIndex)], debugDescription: "No date found at index \(currentIndex)."))
            }
        }
    }

    mutating func nestedContainer<NestedKey>(keyedBy _: NestedKey.Type) throws -> KeyedDecodingContainer<NestedKey> where NestedKey: CodingKey {
        guard !isAtEnd else {
            throw DecodingError.valueNotFound(
                KeyedDecodingContainer<NestedKey>.self,
                DecodingError.Context(
                    codingPath: codingPath + [TOMLKey(intValue: currentIndex)],
                    debugDescription: "Unkeyed container is at end.",
                ),
            )
        }

        guard let nestedTable = try? array.table(atIndex: currentIndex) else {
            throw DecodingError.typeMismatch(
                KeyedDecodingContainer<NestedKey>.self,
                DecodingError.Context(
                    codingPath: codingPath + [TOMLKey(intValue: currentIndex)],
                    debugDescription: "Element is not a table.",
                ),
            )
        }

        var nestedCodingPath = codingPath
        nestedCodingPath.append(TOMLKey(intValue: currentIndex))
        let nestedDecoder = _TOMLDecoder(referencing: .keyed(nestedTable), at: nestedCodingPath, strategy: decoder.strategy, isLenient: decoder.isLenient)

        currentIndex += 1
        let container = TOMLKeyedDecodingContainer<NestedKey>(referencing: nestedDecoder, wrapping: nestedTable)
        return KeyedDecodingContainer(container)
    }

    mutating func nestedUnkeyedContainer() throws -> UnkeyedDecodingContainer {
        guard !isAtEnd else {
            throw DecodingError.valueNotFound(
                UnkeyedDecodingContainer.self,
                DecodingError.Context(
                    codingPath: codingPath + [TOMLKey(intValue: currentIndex)],
                    debugDescription: "Cannot get nested unkeyed container -- unkeyed container is at end.",
                ),
            )
        }

        guard let nestedArray = try? array.array(atIndex: currentIndex) else {
            throw DecodingError.typeMismatch(
                UnkeyedDecodingContainer.self,
                DecodingError.Context(
                    codingPath: codingPath + [TOMLKey(intValue: currentIndex)],
                    debugDescription: "Cannot get nested unkeyed container -- element is not an array.",
                ),
            ),
        }

        var nestedCodingPath = codingPath
        nestedCodingPath.append(TOMLKey(intValue: currentIndex))
        let nestedDecoder = _TOMLDecoder(referencing: .unkeyed(nestedArray), at: nestedCodingPath, strategy: decoder.strategy, isLenient: decoder.isLenient)

        currentIndex += 1
        return TOMLUnkeyedDecodingContainer(referencing: nestedDecoder, wrapping: nestedArray)
    }

    mutating func superDecoder() throws -> Decoder {
        _TOMLDecoder(referencing: .unkeyed(array), at: codingPath + [TOMLKey.super], strategy: decoder.strategy, isLenient: decoder.isLenient)
    }
}
