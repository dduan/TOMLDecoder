%{
# gyb variables available: `__file__` gives the templateâ€™s path.
from pathlib import Path
template_name = Path(__file__).name
generated_file = template_name[:-4] if template_name.endswith('.gyb') else template_name
int_types = ["Int", "Int8", "Int16", "Int32", "UInt", "UInt8", "UInt16", "UInt32", "UInt64"]
native_types = [
    ("Bool", "Bool"),
    ("String", "String"),
    ("Int64", "Integer"),
]
}%
//  WARNING: This file is generated from ${template_name}
//  Do not edit ${generated_file} directly.

import Foundation

extension _TOMLDecoder: SingleValueDecodingContainer {
    var context: TOMLKey {
        codingPath.last as! TOMLKey
    }

    % for native_type in native_types:
    @inline(__always)
    func decode(_: ${native_type[0]}.Type) throws -> ${native_type[0]} {
        try token.unpack${native_type[1]}(source: source, context: context)
    }

    % end
    % for int_type in int_types:
    @inline(__always)
    func decode(_ type: ${int_type}.Type) throws -> ${int_type} {
        if !isLenient {
            throw DecodingError.typeMismatch(type, DecodingError.Context(
                codingPath: codingPath,
                debugDescription: "Use Int64 or lenient decoding strategy."
            ))
        }

        do {
            let integer = try decode(Int64.self)
            guard let result = ${int_type}(exactly: integer) else {
                throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "\(integer) cannot be represented by type Int."))
            }
            return result
        } catch {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: codingPath, debugDescription: "\(error)", underlyingError: error))
        }
    }

    % end
    func decode(_ type: Double.Type) throws -> Double {
        do {
            return try token.unpackFloat(source: source, context: context)
        } catch let floatError {
            do {
                return try Double(from: decode(OffsetDateTime.self), strategy: strategy.timeInterval)
            } catch let error as DecodingError {
                throw error
            } catch {
                throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: codingPath, debugDescription: "\(floatError)", underlyingError: floatError))
            }
        }
    }

    func decode(_ type: Float.Type) throws -> Float {
        if !isLenient {
            throw DecodingError.typeMismatch(type, DecodingError.Context(
                codingPath: codingPath,
                debugDescription: "Use Double or lenient decoding strategy."
            ))
        }
        do {
            return try Float(decode(Double.self))
        } catch {
            throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: codingPath, debugDescription: "\(error)", underlyingError: error))
        }
    }

    @inline(__always)
    func decode<T: Decodable>(_ type: T.Type) throws -> T {
        % for i, type_name in enumerate([t[0] for t in native_types] + int_types + ["Double", "Float"]):
        ${"if" if i == 0 else "} else if"} type == ${type_name}.self {
            return try decode(${type_name}.self) as! T
        % end
        } else if type == LocalDate.self {
            return try decode(LocalDate.self) as! T
        } else if type == LocalDateTime.self {
            return try decode(LocalDateTime.self) as! T
        } else if type == LocalTime.self {
            return try decode(LocalTime.self) as! T
        } else if type == OffsetDateTime.self {
            return try decode(OffsetDateTime.self) as! T
        } else if type == Date.self {
            return try decode(Date.self) as! T
        } else if type == DateComponents.self {
            return try decode(DateComponents.self) as! T
        }
        throw DecodingError.valueNotFound(type, DecodingError.Context(codingPath: codingPath, debugDescription: "Unsupported type \(type)"))
    }

    func decodeNil() -> Bool {
        false
    }
}

extension _TOMLDecoder {
    @inline(__always)
    func decode(_: LocalDate.Type) throws -> LocalDate {
        do {
            return try token.unpackLocalDate(source: source, context: context, exactMatch: !isLenient)
        } catch {
            throw DecodingError.valueNotFound(LocalDate.self, DecodingError.Context(codingPath: codingPath, debugDescription: "\(error)", underlyingError: error))
        }
    }

    @inline(__always)
    func decode(_: LocalDateTime.Type) throws -> LocalDateTime {
        do {
            return try token.unpackLocalDateTime(source: source, context: context, exactMatch: !isLenient)
        } catch {
            throw DecodingError.valueNotFound(LocalDateTime.self, DecodingError.Context(codingPath: codingPath, debugDescription: "\(error)", underlyingError: error))
        }
    }

    @inline(__always)
    func decode(_: LocalTime.Type) throws -> LocalTime {
        do {
            return try token.unpackLocalTime(source: source, context: context, exactMatch: !isLenient)
        } catch {
            throw DecodingError.valueNotFound(LocalTime.self, DecodingError.Context(codingPath: codingPath, debugDescription: "\(error)", underlyingError: error))
        }
    }

    @inline(__always)
    func decode(_: OffsetDateTime.Type) throws -> OffsetDateTime {
        do {
            return try token.unpackOffsetDateTime(source: source, context: context)
        } catch {
            throw DecodingError.valueNotFound(OffsetDateTime.self, DecodingError.Context(codingPath: codingPath, debugDescription: "\(error)", underlyingError: error))
        }
    }

    @inline(__always)
    func decode(_: Date.Type) throws -> Date {
        if !isLenient {
            throw DecodingError.valueNotFound(Date.self, DecodingError.Context(codingPath: codingPath, debugDescription: "No date found."))
        }

        switch strategy.date {
        case .gregorianCalendar:
            do {
                let offsetDateTime = try decode(OffsetDateTime.self)
                return Date(offsetDateTime: offsetDateTime, calendar: Calendar(identifier: .gregorian))
            } catch {
                throw DecodingError.valueNotFound(Date.self, DecodingError.Context(codingPath: codingPath, debugDescription: "\(error)", underlyingError: error))
            }
        case let .calendar(identifiedBy: identifier):
            do {
                let offsetDateTime = try decode(OffsetDateTime.self)
                return Date(offsetDateTime: offsetDateTime, calendar: Calendar(identifier: identifier))
            } catch {
                throw DecodingError.valueNotFound(Date.self, DecodingError.Context(codingPath: codingPath, debugDescription: "\(error)", underlyingError: error))
            }
        case .prolepticGregorianCalendar:
            do {
                let offsetDateTime = try decode(OffsetDateTime.self)
                return Date(timeIntervalSinceReferenceDate: offsetDateTime.timeIntervalSince2001)
            } catch {
                throw DecodingError.valueNotFound(Date.self, DecodingError.Context(codingPath: codingPath, debugDescription: "\(error)", underlyingError: error))
            }
        }
    }

    @inline(__always)
    func decode(_: DateComponents.Type) throws -> DateComponents {
        if !isLenient {
            throw DecodingError.valueNotFound(DateComponents.self, DecodingError.Context(codingPath: codingPath, debugDescription: "No date components found."))
        }

        let datetimeComponents = try token.unpackDateTime(source: source, context: context)
        var components = DateComponents()
        if let date = datetimeComponents.date {
            components.year = Int(date.year)
            components.month = Int(date.month)
            components.day = Int(date.day)
        }
        if let time = datetimeComponents.time {
            components.hour = Int(time.hour)
            components.minute = Int(time.minute)
            components.second = Int(time.second)
        }
        if let offset = datetimeComponents.offset {
            components.timeZone = TimeZone(secondsFromGMT: Int(offset) * 60)
        }
        return components
    }
}
